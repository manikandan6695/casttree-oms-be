import { Injectable, OnModuleInit } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { ISubscriptionModel } from "./schema/subscription.schema";
import { SubscriptionSyncEntity } from "./subscription-sync.entity";

@Injectable()
export class SubscriptionSyncService implements OnModuleInit {
  constructor(
    @InjectModel("subscription")
    private readonly subscriptionModel: Model<ISubscriptionModel>,
    @InjectRepository(SubscriptionSyncEntity)
    private readonly subscriptionRepository: Repository<SubscriptionSyncEntity>
  ) {}

  async onModuleInit() {
    await this.setupChangeStream();
  }

  private async setupChangeStream() {
    const changeStream = this.subscriptionModel.watch([], {
      fullDocument: "updateLookup",
    });

    changeStream.on("change", async (change) => {
      try {
        switch (change.operationType) {
          case "insert":
          case "update":
            await this.handleUpsert(change.fullDocument);
            break;
          case "delete":
            await this.handleDelete(change.documentKey._id);
            break;
        }
      } catch (error) {
        console.error("Error processing subscription change stream:", error);
      }
    });

    changeStream.on("error", (error) => {
      console.error("Subscription change stream error:", error);
    });
  }

  private async handleUpsert(subscription: ISubscriptionModel) {
    try {
      // Check if subscription already exists by mongoId
      const existingSubscription = await this.subscriptionRepository.findOne({
        where: {
          mongoId: subscription._id.toString()
        }
      });

      if (existingSubscription) {
        // Update existing subscription
        const updatedSubscription = this.mapToSubscriptionEntity(subscription);
        updatedSubscription.id = existingSubscription.id; // Keep the existing UUID
        await this.subscriptionRepository.save(updatedSubscription);
        console.log(`Updated subscription ${subscription._id} in SQL database (plan: ${subscription.planId})`);
      } else {
        // Insert new subscription
        const subscriptionEntity = this.mapToSubscriptionEntity(subscription);
        await this.subscriptionRepository.save(subscriptionEntity);
        console.log(`Inserted new subscription ${subscription._id} to SQL database (plan: ${subscription.planId})`);
      }
    } catch (error) {
      console.error(`Error syncing subscription ${subscription._id}:`, error);
    }
  }

  private async handleDelete(subscriptionId: string) {
    try {
      // Find and delete by mongoId
      const existingSubscription = await this.subscriptionRepository.findOne({
        where: {
          mongoId: subscriptionId
        }
      });

      if (existingSubscription) {
        await this.subscriptionRepository.remove(existingSubscription);
        console.log(`Deleted subscription ${subscriptionId} from SQL database`);
      } else {
        console.log(`Subscription ${subscriptionId} not found in SQL database for deletion`);
      }
    } catch (error) {
      console.error(`Error handling delete for subscription ${subscriptionId}:`, error);
    }
  }

  private mapToSubscriptionEntity(subscription: ISubscriptionModel): SubscriptionSyncEntity {
    const subscriptionEntity = new SubscriptionSyncEntity();
    
    // id will be auto-generated by TypeORM as UUID
    subscriptionEntity.mongoId = subscription._id.toString();
    subscriptionEntity.userId = subscription.userId?.toString();
    subscriptionEntity.planId = subscription.planId;
    subscriptionEntity.totalCount = subscription.totalCount;
    subscriptionEntity.currentStart = subscription.currentStart;
    subscriptionEntity.quantity = subscription.quantity;
    subscriptionEntity.currentEnd = subscription.currentEnd;
    subscriptionEntity.startAt = subscription.startAt;
    subscriptionEntity.scheduleChangeAt = subscription.scheduleChangeAt;
    subscriptionEntity.endAt = subscription.endAt;
    subscriptionEntity.paidCount = subscription.paidCount;
    subscriptionEntity.expireBy = subscription.expireBy;
    subscriptionEntity.notes = subscription.notes;
    subscriptionEntity.subscriptionStatus = subscription.subscriptionStatus;
    subscriptionEntity.metaData = subscription.metaData;
    subscriptionEntity.status = subscription.status;
    subscriptionEntity.createdBy = subscription.createdBy?.toString();
    subscriptionEntity.updatedBy = subscription.updatedBy?.toString();
    
    // Timestamps will be auto-managed by TypeORM
    // created_at and updated_at will be set automatically
    
    return subscriptionEntity;
  }

  // Method to manually trigger sync for existing subscriptions
  async syncExistingSubscriptions() {
    try {
      console.log("Starting sync of existing subscriptions...");
      
      const subscriptions = await this.subscriptionModel.find({}).limit(100); // Limit to avoid memory issues
      
      for (const subscription of subscriptions) {
        await this.handleUpsert(subscription);
      }
      
      console.log(`Successfully synced ${subscriptions.length} existing subscriptions`);
    } catch (error) {
      console.error("Error syncing existing subscriptions:", error);
    }
  }

  // Method to get sync status
  async getSyncStatus() {
    try {
      const totalSubscriptions = await this.subscriptionModel.countDocuments({});
      const syncedSubscriptions = await this.subscriptionRepository.count();
      
      console.log(`Total subscriptions in MongoDB: ${totalSubscriptions}`);
      console.log(`Total subscriptions synced to SQL: ${syncedSubscriptions}`);
      
      return {
        totalSubscriptions,
        syncedSubscriptions,
        syncStatus: "active",
        lastSync: new Date()
      };
    } catch (error) {
      console.error("Error getting subscription sync status:", error);
      throw error;
    }
  }

  // Method to get synced subscriptions from SQL database
  async getSyncedSubscriptions(skip: number = 0, limit: number = 10) {
    try {
      const subscriptions = await this.subscriptionRepository.find({
        skip,
        take: limit,
        order: {
          created_at: 'DESC'
        }
      });
      
      return {
        subscriptions,
        total: await this.subscriptionRepository.count(),
        skip,
        limit
      };
    } catch (error) {
      console.error("Error getting synced subscriptions:", error);
      throw error;
    }
  }

  // Method to find subscription by mongoId in SQL database
  async findSyncedSubscriptionByMongoId(mongoId: string) {
    try {
      return await this.subscriptionRepository.findOne({
        where: { mongoId }
      });
    } catch (error) {
      console.error(`Error finding synced subscription by mongoId ${mongoId}:`, error);
      throw error;
    }
  }

  // Method to find subscriptions by userId
  async findSyncedSubscriptionsByUserId(userId: string) {
    try {
      return await this.subscriptionRepository.find({
        where: { userId }
      });
    } catch (error) {
      console.error(`Error finding synced subscriptions by userId ${userId}:`, error);
      throw error;
    }
  }

  // Method to find subscriptions by planId
  async findSyncedSubscriptionsByPlanId(planId: string) {
    try {
      return await this.subscriptionRepository.find({
        where: { planId }
      });
    } catch (error) {
      console.error(`Error finding synced subscriptions by planId ${planId}:`, error);
      throw error;
    }
  }

  // Method to find subscriptions by status
  async findSyncedSubscriptionsByStatus(status: string) {
    try {
      return await this.subscriptionRepository.find({
        where: { status }
      });
    } catch (error) {
      console.error(`Error finding synced subscriptions by status ${status}:`, error);
      throw error;
    }
  }

  // Method to find subscriptions by subscription status
  async findSyncedSubscriptionsBySubscriptionStatus(subscriptionStatus: string) {
    try {
      return await this.subscriptionRepository.find({
        where: { subscriptionStatus }
      });
    } catch (error) {
      console.error(`Error finding synced subscriptions by subscription status ${subscriptionStatus}:`, error);
      throw error;
    }
  }

  // Method to get subscription statistics
  async getSubscriptionStatistics() {
    try {
      const totalSubscriptions = await this.subscriptionRepository.count();
      const activeSubscriptions = await this.subscriptionRepository.count({
        where: { status: "Active" }
      });
      const expiredSubscriptions = await this.subscriptionRepository.count({
        where: { status: "Expired" }
      });
      const cancelledSubscriptions = await this.subscriptionRepository.count({
        where: { status: "Cancelled" }
      });

      return {
        totalSubscriptions,
        activeSubscriptions,
        expiredSubscriptions,
        cancelledSubscriptions,
        lastUpdated: new Date()
      };
    } catch (error) {
      console.error("Error getting subscription statistics:", error);
      throw error;
    }
  }
}
