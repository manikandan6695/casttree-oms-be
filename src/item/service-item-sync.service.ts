import { Injectable, OnModuleInit } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { serviceitems } from "./schema/serviceItem.schema";
import { ServiceItemSyncEntity } from "./service-item-sync.entity";

@Injectable()
export class ServiceItemSyncService implements OnModuleInit {
  constructor(
    @InjectModel("serviceitems")
    private readonly serviceItemModel: Model<serviceitems>,
    @InjectRepository(ServiceItemSyncEntity)
    private readonly serviceItemRepository: Repository<ServiceItemSyncEntity>
  ) {}

  async onModuleInit() {
    await this.setupChangeStream();
  }

  private async setupChangeStream() {
    const changeStream = this.serviceItemModel.watch([], {
      fullDocument: "updateLookup",
    });

    changeStream.on("change", async (change) => {
      try {
        switch (change.operationType) {
          case "insert":
          case "update":
            await this.handleUpsert(change.fullDocument);
            break;
          case "delete":
            await this.handleDelete(change.documentKey._id);
            break;
        }
      } catch (error) {
        console.error("Error processing service item change stream:", error);
      }
    });

    changeStream.on("error", (error) => {
      console.error("Service item change stream error:", error);
    });
  }

  private async handleUpsert(serviceItem: serviceitems) {
    try {
      // Check if service item already exists by mongoId
      const existingServiceItem = await this.serviceItemRepository.findOne({
        where: {
          mongoId: serviceItem._id.toString()
        }
      });

      if (existingServiceItem) {
        // Update existing service item
        const updatedServiceItem = this.mapToServiceItemEntity(serviceItem);
        updatedServiceItem.id = existingServiceItem.id; // Keep the existing UUID
        await this.serviceItemRepository.save(updatedServiceItem);
        console.log(`Updated service item ${serviceItem._id} in SQL database`);
      } else {
        // Insert new service item
        const serviceItemEntity = this.mapToServiceItemEntity(serviceItem);
        await this.serviceItemRepository.save(serviceItemEntity);
        console.log(`Inserted new service item ${serviceItem._id} to SQL database`);
      }
    } catch (error) {
      console.error(`Error syncing service item ${serviceItem._id}:`, error);
    }
  }

  private async handleDelete(serviceItemId: string) {
    try {
      // Find and delete by mongoId
      const existingServiceItem = await this.serviceItemRepository.findOne({
        where: {
          mongoId: serviceItemId
        }
      });

      if (existingServiceItem) {
        await this.serviceItemRepository.remove(existingServiceItem);
        console.log(`Deleted service item ${serviceItemId} from SQL database`);
      } else {
        console.log(`Service item ${serviceItemId} not found in SQL database for deletion`);
      }
    } catch (error) {
      console.error(`Error handling delete for service item ${serviceItemId}:`, error);
    }
  }

  private mapToServiceItemEntity(serviceItem: serviceitems): ServiceItemSyncEntity {
    const serviceItemEntity = new ServiceItemSyncEntity();
    
    // id will be auto-generated by TypeORM as UUID
    serviceItemEntity.mongoId = serviceItem._id.toString();
    serviceItemEntity.itemId = serviceItem.itemId?.toString();
    serviceItemEntity.userId = serviceItem.userId?.toString();
    serviceItemEntity.respondTime = serviceItem.respondTime;
    serviceItemEntity.itemSold = serviceItem.itemSold;
    serviceItemEntity.type = serviceItem.type;
    serviceItemEntity.priorityOrder = serviceItem.priorityOrder;
    serviceItemEntity.status = serviceItem.status;
    
    // JSON fields
    serviceItemEntity.skill = serviceItem.skill;
    serviceItemEntity.language = serviceItem.language;
    serviceItemEntity.expertise = serviceItem.expertise;
    serviceItemEntity.tag = serviceItem.tag;
    serviceItemEntity.additionalDetails = serviceItem.additionalDetails;
    
    // Timestamps will be auto-managed by TypeORM
    // created_at and updated_at will be set automatically
    
    return serviceItemEntity;
  }

  // Method to manually trigger sync for existing service items
  async syncExistingServiceItems() {
    try {
      console.log("Starting sync of existing service items...");
      
      const serviceItems = await this.serviceItemModel.find({}).limit(100); // Limit to avoid memory issues
      
      for (const serviceItem of serviceItems) {
        await this.handleUpsert(serviceItem);
      }
      
      console.log(`Successfully synced ${serviceItems.length} existing service items`);
    } catch (error) {
      console.error("Error syncing existing service items:", error);
    }
  }

  // Method to get sync status
  async getSyncStatus() {
    try {
      const totalServiceItems = await this.serviceItemModel.countDocuments({});
      const syncedServiceItems = await this.serviceItemRepository.count();
      
      console.log(`Total service items in MongoDB: ${totalServiceItems}`);
      console.log(`Total service items synced to SQL: ${syncedServiceItems}`);
      
      return {
        totalServiceItems,
        syncedServiceItems,
        syncStatus: "active",
        lastSync: new Date()
      };
    } catch (error) {
      console.error("Error getting service item sync status:", error);
      throw error;
    }
  }

  // Method to get synced service items from SQL database
  async getSyncedServiceItems(skip: number = 0, limit: number = 10) {
    try {
      const serviceItems = await this.serviceItemRepository.find({
        skip,
        take: limit,
        order: {
          created_at: 'DESC'
        }
      });
      
      return {
        serviceItems,
        total: await this.serviceItemRepository.count(),
        skip,
        limit
      };
    } catch (error) {
      console.error("Error getting synced service items:", error);
      throw error;
    }
  }

  // Method to find service item by mongoId in SQL database
  async findSyncedServiceItemByMongoId(mongoId: string) {
    try {
      return await this.serviceItemRepository.findOne({
        where: { mongoId }
      });
    } catch (error) {
      console.error(`Error finding synced service item by mongoId ${mongoId}:`, error);
      throw error;
    }
  }
}
