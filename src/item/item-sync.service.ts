import { Injectable, OnModuleInit } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { IItemModel } from "./schema/item.schema";
import { ItemSyncEntity } from "./item-sync.entity";

@Injectable()
export class ItemSyncService implements OnModuleInit {
  constructor(
    @InjectModel("item")
    private readonly itemModel: Model<IItemModel>,
    @InjectRepository(ItemSyncEntity)
    private readonly itemRepository: Repository<ItemSyncEntity>
  ) {}

  async onModuleInit() {
    await this.setupChangeStream();
  }

  private async setupChangeStream() {
    const changeStream = this.itemModel.watch([], {
      fullDocument: "updateLookup",
    });

    changeStream.on("change", async (change) => {
      try {
        switch (change.operationType) {
          case "insert":
          case "update":
            await this.handleUpsert(change.fullDocument);
            break;
          case "delete":
            await this.handleDelete(change.documentKey._id);
            break;
        }
      } catch (error) {
        console.error("Error processing item change stream:", error);
      }
    });

    changeStream.on("error", (error) => {
      console.error("Item change stream error:", error);
    });
  }

  private async handleUpsert(item: IItemModel) {
    try {
      // Check if item already exists by mongoId
      const existingItem = await this.itemRepository.findOne({
        where: {
          mongoId: item._id.toString()
        }
      });

      if (existingItem) {
        // Update existing item
        const updatedItem = this.mapToItemEntity(item);
        updatedItem.id = existingItem.id; // Keep the existing UUID
        await this.itemRepository.save(updatedItem);
        console.log(`Updated item ${item._id} in SQL database (name: ${item.itemName})`);
      } else {
        // Insert new item
        const itemEntity = this.mapToItemEntity(item);
        await this.itemRepository.save(itemEntity);
        console.log(`Inserted new item ${item._id} to SQL database (name: ${item.itemName})`);
      }
    } catch (error) {
      console.error(`Error syncing item ${item._id}:`, error);
    }
  }

  private async handleDelete(itemId: string) {
    try {
      // Find and delete by mongoId
      const existingItem = await this.itemRepository.findOne({
        where: {
          mongoId: itemId
        }
      });

      if (existingItem) {
        await this.itemRepository.remove(existingItem);
        console.log(`Deleted item ${itemId} from SQL database`);
      } else {
        console.log(`Item ${itemId} not found in SQL database for deletion`);
      }
    } catch (error) {
      console.error(`Error handling delete for item ${itemId}:`, error);
    }
  }

  private mapToItemEntity(item: IItemModel): ItemSyncEntity {
    const itemEntity = new ItemSyncEntity();
    
    // id will be auto-generated by TypeORM as UUID
    itemEntity.mongoId = item._id.toString();
    itemEntity.orgId = item.orgId?.toString();
    itemEntity.platformItemId = item.platformItemId?.toString();
    itemEntity.item_type = item.item_type;
    itemEntity.itemName = item.itemName;
    itemEntity.item_sku = item.item_sku;
    itemEntity.itemDescription = item.itemDescription;
    itemEntity.item_short_description = item.item_short_description;
    itemEntity.item_long_description = item.item_long_description;
    itemEntity.item_sub_type = item.item_sub_type;
    itemEntity.parent_item_id = item.parent_item_id?.toString();
    itemEntity.show_in_list = item.show_in_list;
    itemEntity.item_classification_type = item.item_classification_type;
    itemEntity.item_base_unit_of_measurement = item.item_base_unit_of_measurement;
    itemEntity.uom_id = item.uom_id?.toString();
    itemEntity.is_sales_configure = item.is_sales_configure;
    itemEntity.itemCategory = item.itemCategory?.toString();
    itemEntity.itemSubCategory = item.itemSubCategory?.toString();
    itemEntity.itemGroupId = item.itemGroupId?.toString();
    itemEntity.itemCommissionMarkupType = item.itemCommissionMarkupType;
    itemEntity.itemCommissionMarkup = item.itemCommissionMarkup;
    itemEntity.isItemCommissionIncluded = item.isItemCommissionIncluded;
    itemEntity.item_returnable = item.item_returnable;
    itemEntity.reorder_point = Number(item.reorder_point);
    itemEntity.stock_alert = Number(item.stock_alert);
    itemEntity.upc = item.upc;
    itemEntity.ean = item.ean;
    itemEntity.mpn = item.mpn;
    itemEntity.isbn = item.isbn;
    itemEntity.item_tax_preference = item.item_tax_preference;
    itemEntity.excemption_reason = item.excemption_reason?.toString();
    itemEntity.track_inventory = item.track_inventory;
    itemEntity.item_inventory_account = item.item_inventory_account?.toString();
    itemEntity.item_manufacturer = item.item_manufacturer?.toString();
    itemEntity.item_brand = item.item_brand?.toString();
    itemEntity.seo_url = item.seo_url;
    itemEntity.seo_title = item.seo_title;
    itemEntity.seo_description = item.seo_description;
    itemEntity.preffered_vendors = item.preffered_vendors?.toString();
    itemEntity.data_create_mode = item.data_create_mode;
    itemEntity.comparePrice = item.comparePrice;
    itemEntity.status = item.status;
    itemEntity.created_by = item.created_by?.toString();
    itemEntity.updated_by = item.updated_by?.toString();
    itemEntity.E_material_code = item.E_material_code;
    
    // JSON fields
    itemEntity.media = item.media;
    itemEntity.geo = item.geo;
    itemEntity.item_codes = item.item_codes;
    itemEntity.itemStatusHistory = item.itemStatusHistory;
    itemEntity.item_sales_info = item.item_sales_info;
    itemEntity.item_purchase_info = item.item_purchase_info;
    itemEntity.item_sales_channel = item.item_sales_channel;
    itemEntity.item_dimensions = item.item_dimensions;
    itemEntity.item_weight = item.item_weight;
    itemEntity.item_taxes = item.item_taxes;
    itemEntity.characteristics = item.characteristics;
    itemEntity.variant = item.variant;
    itemEntity.stock_details = item.stock_details;
    itemEntity.additionalDetail = item.additionalDetail;
    itemEntity.itemCommissionMarkupCurrency = item.itemCommissionMarkupCurrency;
    itemEntity.tags = item.tags;
    
    // Timestamps will be auto-managed by TypeORM
    // created_at and updated_at will be set automatically
    
    return itemEntity;
  }

  // Method to manually trigger sync for existing items
  async syncExistingItems() {
    try {
      console.log("Starting sync of existing items...");
      
      const items = await this.itemModel.find({}).limit(100); // Limit to avoid memory issues
      
      for (const item of items) {
        await this.handleUpsert(item);
      }
      
      console.log(`Successfully synced ${items.length} existing items`);
    } catch (error) {
      console.error("Error syncing existing items:", error);
    }
  }

  // Method to get sync status
  async getSyncStatus() {
    try {
      const totalItems = await this.itemModel.countDocuments({});
      const syncedItems = await this.itemRepository.count();
      
      console.log(`Total items in MongoDB: ${totalItems}`);
      console.log(`Total items synced to SQL: ${syncedItems}`);
      
      return {
        totalItems,
        syncedItems,
        syncStatus: "active",
        lastSync: new Date()
      };
    } catch (error) {
      console.error("Error getting sync status:", error);
      throw error;
    }
  }

  // Method to get synced items from SQL database
  async getSyncedItems(skip: number = 0, limit: number = 10) {
    try {
      const items = await this.itemRepository.find({
        skip,
        take: limit,
        order: {
          created_at: 'DESC'
        }
      });
      
      return {
        items,
        total: await this.itemRepository.count(),
        skip,
        limit
      };
    } catch (error) {
      console.error("Error getting synced items:", error);
      throw error;
    }
  }

  // Method to find item by mongoId in SQL database
  async findSyncedItemByMongoId(mongoId: string) {
    try {
      return await this.itemRepository.findOne({
        where: { mongoId }
      });
    } catch (error) {
      console.error(`Error finding synced item by mongoId ${mongoId}:`, error);
      throw error;
    }
  }
}
