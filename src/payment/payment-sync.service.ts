import { Injectable, OnModuleInit } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { IPaymentModel } from "./schema/payment.schema";
import { PaymentSyncEntity } from "./payment-sync.entity";

@Injectable()
export class PaymentSyncService implements OnModuleInit {
  constructor(
    @InjectModel("payment")
    private readonly paymentModel: Model<IPaymentModel>,
    @InjectRepository(PaymentSyncEntity)
    private readonly paymentRepository: Repository<PaymentSyncEntity>
  ) {}

  async onModuleInit() {
    await this.setupChangeStream();
  }

  private async setupChangeStream() {
    const changeStream = this.paymentModel.watch([], {
      fullDocument: "updateLookup",
    });

    changeStream.on("change", async (change) => {
      try {
        switch (change.operationType) {
          case "insert":
          case "update":
            await this.handleUpsert(change.fullDocument);
            break;
          case "delete":
            await this.handleDelete(change.documentKey._id);
            break;
        }
      } catch (error) {
        console.error("Error processing payment change stream:", error);
      }
    });

    changeStream.on("error", (error) => {
      console.error("Payment change stream error:", error);
    });
  }

  private async handleUpsert(payment: IPaymentModel) {
    try {
      // Check if payment already exists by mongoId
      const existingPayment = await this.paymentRepository.findOne({
        where: {
          mongoId: payment._id.toString()
        }
      });

      if (existingPayment) {
        // Update existing payment
        const updatedPayment = this.mapToPaymentEntity(payment);
        updatedPayment.id = existingPayment.id; // Keep the existing UUID
        await this.paymentRepository.save(updatedPayment);
        console.log(`Updated payment ${payment._id} in SQL database (order: ${payment.payment_order_id})`);
      } else {
        // Insert new payment
        const paymentEntity = this.mapToPaymentEntity(payment);
        await this.paymentRepository.save(paymentEntity);
        console.log(`Inserted new payment ${payment._id} to SQL database (order: ${payment.payment_order_id})`);
      }
    } catch (error) {
      console.error(`Error syncing payment ${payment._id}:`, error);
    }
  }

  private async handleDelete(paymentId: string) {
    try {
      // Find and delete by mongoId
      const existingPayment = await this.paymentRepository.findOne({
        where: {
          mongoId: paymentId
        }
      });

      if (existingPayment) {
        await this.paymentRepository.remove(existingPayment);
        console.log(`Deleted payment ${paymentId} from SQL database`);
      } else {
        console.log(`Payment ${paymentId} not found in SQL database for deletion`);
      }
    } catch (error) {
      console.error(`Error handling delete for payment ${paymentId}:`, error);
    }
  }

  private mapToPaymentEntity(payment: IPaymentModel): PaymentSyncEntity {
    const paymentEntity = new PaymentSyncEntity();
    
    // id will be auto-generated by TypeORM as UUID
    paymentEntity.mongoId = payment._id.toString();
    paymentEntity.user_id = payment.user_id?.toString();
    paymentEntity.source_id = payment.source_id?.toString();
    paymentEntity.source_type = payment.source_type;
    paymentEntity.document_status = payment.document_status;
    paymentEntity.transaction_type = payment.transaction_type;
    paymentEntity.payment_date = payment.payment_date;
    paymentEntity.tendered_amount = payment.tendered_amount;
    paymentEntity.payment_order_id = payment.payment_order_id;
    paymentEntity.document_id = payment.document_id?.toString();
    paymentEntity.document_type_name = payment.document_type_name;
    paymentEntity.doc_id_gen_type = payment.doc_id_gen_type;
    paymentEntity.payment_doc_id_prefix = payment.payment_doc_id_prefix;
    paymentEntity.payment_doc_id = payment.payment_doc_id;
    paymentEntity.payment_document_number = payment.payment_document_number;
    paymentEntity.document_number = payment.document_number;
    paymentEntity.place_of_supply = payment.place_of_supply?.toString();
    paymentEntity.source_of_supply = payment.source_of_supply?.toString();
    paymentEntity.description_of_supply = payment.description_of_supply;
    paymentEntity.amount = payment.amount;
    paymentEntity.total_tax_amount = payment.total_tax_amount;
    paymentEntity.branch = payment.branch?.toString();
    paymentEntity.unused_amount = payment.unused_amount;
    paymentEntity.type = payment.type;
    paymentEntity.bank_charges = payment.bank_charges;
    paymentEntity.is_tds_deducted = payment.is_tds_deducted;
    paymentEntity.is_reverese_charge_applied = payment.is_reverese_charge_applied;
    paymentEntity.tds_tax_account = payment.tds_tax_account?.toString();
    paymentEntity.tax = payment.tax?.toString();
    paymentEntity.status = payment.status;
    paymentEntity.internal_notes = payment.internal_notes;
    paymentEntity.reference_number = payment.reference_number;
    paymentEntity.payment_mode = payment.payment_mode?.toString();
    paymentEntity.account = payment.account?.toString();
    paymentEntity.currencyCode = payment.currencyCode;
    paymentEntity.currency = payment.currency?.toString();
    paymentEntity.created_by = payment.created_by?.toString();
    paymentEntity.updated_by = payment.updated_by?.toString();
    
    // Timestamps will be auto-managed by TypeORM
    // created_at and updated_at will be set automatically
    
    return paymentEntity;
  }

  // Method to manually trigger sync for existing payments
  async syncExistingPayments() {
    try {
      console.log("Starting sync of existing payments...");
      
      const payments = await this.paymentModel.find({}).limit(100); // Limit to avoid memory issues
      
      for (const payment of payments) {
        await this.handleUpsert(payment);
      }
      
      console.log(`Successfully synced ${payments.length} existing payments`);
    } catch (error) {
      console.error("Error syncing existing payments:", error);
    }
  }

  // Method to get sync status
  async getSyncStatus() {
    try {
      const totalPayments = await this.paymentModel.countDocuments({});
      const syncedPayments = await this.paymentRepository.count();
      
      console.log(`Total payments in MongoDB: ${totalPayments}`);
      console.log(`Total payments synced to SQL: ${syncedPayments}`);
      
      return {
        totalPayments,
        syncedPayments,
        syncStatus: "active",
        lastSync: new Date()
      };
    } catch (error) {
      console.error("Error getting payment sync status:", error);
      throw error;
    }
  }

  // Method to get synced payments from SQL database
  async getSyncedPayments(skip: number = 0, limit: number = 10) {
    try {
      const payments = await this.paymentRepository.find({
        skip,
        take: limit,
        order: {
          created_at: 'DESC'
        }
      });
      
      return {
        payments,
        total: await this.paymentRepository.count(),
        skip,
        limit
      };
    } catch (error) {
      console.error("Error getting synced payments:", error);
      throw error;
    }
  }

  // Method to find payment by mongoId in SQL database
  async findSyncedPaymentByMongoId(mongoId: string) {
    try {
      return await this.paymentRepository.findOne({
        where: { mongoId }
      });
    } catch (error) {
      console.error(`Error finding synced payment by mongoId ${mongoId}:`, error);
      throw error;
    }
  }

  // Method to find payments by payment order ID
  async findSyncedPaymentsByOrderId(paymentOrderId: string) {
    try {
      return await this.paymentRepository.find({
        where: { payment_order_id: paymentOrderId }
      });
    } catch (error) {
      console.error(`Error finding synced payments by order ID ${paymentOrderId}:`, error);
      throw error;
    }
  }

  // Method to find payments by status
  async findSyncedPaymentsByStatus(status: string) {
    try {
      return await this.paymentRepository.find({
        where: { status: status }
      });
    } catch (error) {
      console.error(`Error finding synced payments by status ${status}:`, error);
      throw error;
    }
  }

  // Method to get payment statistics
  async getPaymentStatistics() {
    try {
      const totalPayments = await this.paymentRepository.count();
      const pendingPayments = await this.paymentRepository.count({
        where: { status: "Pending" }
      });
      const completedPayments = await this.paymentRepository.count({
        where: { status: "Completed" }
      });
      const failedPayments = await this.paymentRepository.count({
        where: { status: "Failed" }
      });

      return {
        totalPayments,
        pendingPayments,
        completedPayments,
        failedPayments,
        lastUpdated: new Date()
      };
    } catch (error) {
      console.error("Error getting payment statistics:", error);
      throw error;
    }
  }
}
