import { Injectable, OnModuleInit } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { ISalesDocumentModel } from "./schema/sales-document.schema";
import { SalesDocumentSyncEntity } from "./sales-document-sync.entity";

@Injectable()
export class SalesDocumentSyncService implements OnModuleInit {
  constructor(
    @InjectModel("salesDocument")
    private readonly salesDocumentModel: Model<ISalesDocumentModel>,
    @InjectRepository(SalesDocumentSyncEntity)
    private readonly salesDocumentRepository: Repository<SalesDocumentSyncEntity>
  ) {}

  async onModuleInit() {
    await this.setupChangeStream();
  }

  private async setupChangeStream() {
    const changeStream = this.salesDocumentModel.watch([], {
      fullDocument: "updateLookup",
    });

    changeStream.on("change", async (change) => {
      try {
        switch (change.operationType) {
          case "insert":
          case "update":
            await this.handleUpsert(change.fullDocument);
            break;
          case "delete":
            await this.handleDelete(change.documentKey._id);
            break;
        }
      } catch (error) {
        console.error("Error processing sales document change stream:", error);
      }
    });

    changeStream.on("error", (error) => {
      console.error("Sales document change stream error:", error);
    });
  }

  private async handleUpsert(salesDocument: ISalesDocumentModel) {
    try {
      // Check if sales document already exists by mongoId
      const existingSalesDocument = await this.salesDocumentRepository.findOne({
        where: {
          mongoId: salesDocument._id.toString()
        }
      });

      if (existingSalesDocument) {
        // Update existing sales document
        const updatedSalesDocument = this.mapToSalesDocumentEntity(salesDocument);
        updatedSalesDocument.id = existingSalesDocument.id; // Keep the existing UUID
        await this.salesDocumentRepository.save(updatedSalesDocument);
        console.log(`Updated sales document ${salesDocument._id} in SQL database (number: ${salesDocument.sales_document_number})`);
      } else {
        // Insert new sales document
        const salesDocumentEntity = this.mapToSalesDocumentEntity(salesDocument);
        await this.salesDocumentRepository.save(salesDocumentEntity);
        console.log(`Inserted new sales document ${salesDocument._id} to SQL database (number: ${salesDocument.sales_document_number})`);
      }
    } catch (error) {
      console.error(`Error syncing sales document ${salesDocument._id}:`, error);
    }
  }

  private async handleDelete(salesDocumentId: string) {
    try {
      // Find and delete by mongoId
      const existingSalesDocument = await this.salesDocumentRepository.findOne({
        where: {
          mongoId: salesDocumentId
        }
      });

      if (existingSalesDocument) {
        await this.salesDocumentRepository.remove(existingSalesDocument);
        console.log(`Deleted sales document ${salesDocumentId} from SQL database`);
      } else {
        console.log(`Sales document ${salesDocumentId} not found in SQL database for deletion`);
      }
    } catch (error) {
      console.error(`Error handling delete for sales document ${salesDocumentId}:`, error);
    }
  }

  private mapToSalesDocumentEntity(salesDocument: ISalesDocumentModel): SalesDocumentSyncEntity {
    const salesDocumentEntity = new SalesDocumentSyncEntity();
    
    // id will be auto-generated by TypeORM as UUID
    salesDocumentEntity.mongoId = salesDocument._id.toString();
    salesDocumentEntity.source_id = salesDocument.source_id?.toString();
    salesDocumentEntity.source_type = salesDocument.source_type;
    salesDocumentEntity.document_id = salesDocument.document_id?.toString();
    salesDocumentEntity.document_type_name = salesDocument.document_type_name;
    salesDocumentEntity.doc_id_gen_type = salesDocument.doc_id_gen_type;
    salesDocumentEntity.sales_doc_id_prefix = salesDocument.sales_doc_id_prefix;
    salesDocumentEntity.sales_doc_id = salesDocument.sales_doc_id;
    salesDocumentEntity.sales_document_number = salesDocument.sales_document_number;
    salesDocumentEntity.document_number = salesDocument.document_number;
    salesDocumentEntity.E_doc_id = salesDocument.E_doc_id;
    salesDocumentEntity.document_status = salesDocument.document_status;
    salesDocumentEntity.item_count = salesDocument.item_count;
    salesDocumentEntity.currency = salesDocument.currency?.toString();
    salesDocumentEntity.currencyCode = salesDocument.currencyCode;
    salesDocumentEntity.sub_total = salesDocument.sub_total;
    salesDocumentEntity.due_date = salesDocument.due_date as Date;
    salesDocumentEntity.due_status = salesDocument.due_status;
    salesDocumentEntity.discount_type = salesDocument.discount_type;
    salesDocumentEntity.discount_level = salesDocument.discount_level;
    salesDocumentEntity.discount = salesDocument.discount;
    salesDocumentEntity.discount_amount = salesDocument.discount_amount;
    salesDocumentEntity.adjustments = salesDocument.adjustments;
    salesDocumentEntity.grand_total = salesDocument.grand_total;
    salesDocumentEntity.balance = salesDocument.balance;
    salesDocumentEntity.status = salesDocument.status;
    salesDocumentEntity.refund = salesDocument.refund;
    salesDocumentEntity.created_by = salesDocument.created_by?.toString();
    salesDocumentEntity.updated_by = salesDocument.updated_by?.toString();
    
    // Additional fields from schema
    salesDocumentEntity.branch = (salesDocument as any).branch?.toString();
    salesDocumentEntity.tax_treatment = (salesDocument as any).tax_treatment?.toString();
    salesDocumentEntity.acknowledgement_status = (salesDocument as any).acknowledgement_status;
    salesDocumentEntity.acknowledgement_reason = (salesDocument as any).acknowledgement_reason;
    salesDocumentEntity.acknowledged_date = (salesDocument as any).acknowledged_date;
    salesDocumentEntity.is_viewed_by_recipient = (salesDocument as any).is_viewed_by_recipient;
    salesDocumentEntity.recipient_viewed_on = (salesDocument as any).recipient_viewed_on;
    salesDocumentEntity.is_email_dispatched = (salesDocument as any).is_email_dispatched;
    salesDocumentEntity.price_list_id = (salesDocument as any).price_list_id?.toString();
    salesDocumentEntity.reference_number = (salesDocument as any).reference_number;
    salesDocumentEntity.sales_date = (salesDocument as any).sales_date;
    salesDocumentEntity.sales_expiry_date = (salesDocument as any).sales_expiry_date;
    salesDocumentEntity.sales_expected_ship_date = (salesDocument as any).sales_expected_ship_date;
    salesDocumentEntity.payment_terms = (salesDocument as any).payment_terms?.toString();
    salesDocumentEntity.warehouse = (salesDocument as any).warehouse?.toString();
    salesDocumentEntity.sales_person = (salesDocument as any).sales_person?.toString();
    salesDocumentEntity.added_type = (salesDocument as any).added_type;
    salesDocumentEntity.added_type_description = (salesDocument as any).added_type_description;
    salesDocumentEntity.shipping_charge = (salesDocument as any).shipping_charge;
    
    // Timestamps will be auto-managed by TypeORM
    // created_at and updated_at will be set automatically
    
    return salesDocumentEntity;
  }

  // Method to manually trigger sync for existing sales documents
  async syncExistingSalesDocuments() {
    try {
      console.log("Starting sync of existing sales documents...");
      
      const salesDocuments = await this.salesDocumentModel.find({}).limit(100); // Limit to avoid memory issues
      
      for (const salesDocument of salesDocuments) {
        await this.handleUpsert(salesDocument);
      }
      
      console.log(`Successfully synced ${salesDocuments.length} existing sales documents`);
    } catch (error) {
      console.error("Error syncing existing sales documents:", error);
    }
  }

  // Method to get sync status
  async getSyncStatus() {
    try {
      const totalSalesDocuments = await this.salesDocumentModel.countDocuments({});
      const syncedSalesDocuments = await this.salesDocumentRepository.count();
      
      console.log(`Total sales documents in MongoDB: ${totalSalesDocuments}`);
      console.log(`Total sales documents synced to SQL: ${syncedSalesDocuments}`);
      
      return {
        totalSalesDocuments,
        syncedSalesDocuments,
        syncStatus: "active",
        lastSync: new Date()
      };
    } catch (error) {
      console.error("Error getting sales document sync status:", error);
      throw error;
    }
  }

  // Method to get synced sales documents from SQL database
  async getSyncedSalesDocuments(skip: number = 0, limit: number = 10) {
    try {
      const salesDocuments = await this.salesDocumentRepository.find({
        skip,
        take: limit,
        order: {
          created_at: 'DESC'
        }
      });
      
      return {
        salesDocuments,
        total: await this.salesDocumentRepository.count(),
        skip,
        limit
      };
    } catch (error) {
      console.error("Error getting synced sales documents:", error);
      throw error;
    }
  }

  // Method to find sales document by mongoId in SQL database
  async findSyncedSalesDocumentByMongoId(mongoId: string) {
    try {
      return await this.salesDocumentRepository.findOne({
        where: { mongoId }
      });
    } catch (error) {
      console.error(`Error finding synced sales document by mongoId ${mongoId}:`, error);
      throw error;
    }
  }

  // Method to find sales documents by document number
  async findSyncedSalesDocumentsByDocumentNumber(documentNumber: string) {
    try {
      return await this.salesDocumentRepository.find({
        where: { document_number: documentNumber }
      });
    } catch (error) {
      console.error(`Error finding synced sales documents by document number ${documentNumber}:`, error);
      throw error;
    }
  }
}
