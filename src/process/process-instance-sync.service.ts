import { Injectable, OnModuleInit } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { processInstanceModel } from "./schema/processInstance.schema";
import { ProcessInstanceSyncEntity } from "./process-instance-sync.entity";

@Injectable()
export class ProcessInstanceSyncService implements OnModuleInit {
  constructor(
    @InjectModel("processInstance")
    private readonly processInstanceModel: Model<processInstanceModel>,
    @InjectRepository(ProcessInstanceSyncEntity)
    private readonly processInstanceRepository: Repository<ProcessInstanceSyncEntity>
  ) {}

  async onModuleInit() {
    await this.setupChangeStream();
  }

  private async setupChangeStream() {
    const changeStream = this.processInstanceModel.watch([], {
      fullDocument: "updateLookup",
    });

    changeStream.on("change", async (change) => {
      try {
        switch (change.operationType) {
          case "insert":
          case "update":
            await this.handleUpsert(change.fullDocument);
            break;
          case "delete":
            await this.handleDelete(change.documentKey._id);
            break;
        }
      } catch (error) {
        console.error("Error processing process instance change stream:", error);
      }
    });

    changeStream.on("error", (error) => {
      console.error("Process instance change stream error:", error);
    });
  }

  private async handleUpsert(processInstance: any) {
    try {
      // Check if process instance already exists by mongoId
      const existingProcessInstance = await this.processInstanceRepository.findOne({
        where: {
          mongoId: processInstance?._id?.toString()
        }
      });

      if (existingProcessInstance) {
        // Update existing process instance
        const updatedProcessInstance = this.mapToProcessInstanceEntity(processInstance);
        updatedProcessInstance.id = existingProcessInstance.id; // Keep the existing UUID
        await this.processInstanceRepository.save(updatedProcessInstance);
        console.log(`Updated process instance ${processInstance?._id} in SQL database (order: ${processInstance.orderId})`);
      } else {
        // Insert new process instance
        const processInstanceEntity = this.mapToProcessInstanceEntity(processInstance);
        await this.processInstanceRepository.save(processInstanceEntity);
            console.log(`Inserted new process instance ${processInstance?._id} to SQL database (order: ${processInstance.orderId})`);
      }
    } catch (error) {
      console.error(`Error syncing process instance ${processInstance?._id}:`, error);
    }
  }

  private async handleDelete(processInstanceId: string) {
    try {
      // Find and delete by mongoId
      const existingProcessInstance = await this.processInstanceRepository.findOne({
        where: {
          mongoId: processInstanceId
        }
      });

      if (existingProcessInstance) {
        await this.processInstanceRepository.remove(existingProcessInstance);
        console.log(`Deleted process instance ${processInstanceId} from SQL database`);
      } else {
        console.log(`Process instance ${processInstanceId} not found in SQL database for deletion`);
      }
    } catch (error) {
      console.error(`Error handling delete for process instance ${processInstanceId}:`, error);
    }
  }

  private mapToProcessInstanceEntity(processInstance: any): ProcessInstanceSyncEntity {
    const processInstanceEntity = new ProcessInstanceSyncEntity();
    
    // id will be auto-generated by TypeORM as UUID
    processInstanceEntity.mongoId = processInstance?._id?.toString();
    processInstanceEntity.userId = processInstance.userId?.toString();
    processInstanceEntity.processId = processInstance.processId?.toString();
    processInstanceEntity.processType = processInstance.processType;
    processInstanceEntity.startedAt = new Date(processInstance.startedAt);
    processInstanceEntity.orderId = processInstance.orderId;
    processInstanceEntity.processStatus = processInstance.processStatus;
    processInstanceEntity.progressPercentage = Number(processInstance.progressPercentage);
    processInstanceEntity.currentTask = processInstance.currentTask?.toString();
    processInstanceEntity.purchasedAt = new Date(processInstance.purchasedAt);
    processInstanceEntity.validTill = new Date(processInstance.validTill);
    processInstanceEntity.status = processInstance.status;
    processInstanceEntity.createdBy = processInstance.createdBy?.toString();
    processInstanceEntity.updatedBy = processInstance.updatedBy?.toString();
    
    // Timestamps will be auto-managed by TypeORM
    // created_at and updated_at will be set automatically
    
    return processInstanceEntity;
  }

  // Method to manually trigger sync for existing process instances
  async syncExistingProcessInstances() {
    try {
      console.log("Starting sync of existing process instances...");
      
      const processInstances = await this.processInstanceModel.find({}).limit(100); // Limit to avoid memory issues
      
      for (const processInstance of processInstances) {
        await this.handleUpsert(processInstance);
      }
      
      console.log(`Successfully synced ${processInstances.length} existing process instances`);
    } catch (error) {
      console.error("Error syncing existing process instances:", error);
    }
  }

  // Method to get sync status
  async getSyncStatus() {
    try {
      const totalProcessInstances = await this.processInstanceModel.countDocuments({});
      const syncedProcessInstances = await this.processInstanceRepository.count();
      
      console.log(`Total process instances in MongoDB: ${totalProcessInstances}`);
      console.log(`Total process instances synced to SQL: ${syncedProcessInstances}`);
      
      return {
        totalProcessInstances,
        syncedProcessInstances,
        syncStatus: "active",
        lastSync: new Date()
      };
    } catch (error) {
      console.error("Error getting process instance sync status:", error);
      throw error;
    }
  }

  // Method to get synced process instances from SQL database
  async getSyncedProcessInstances(skip: number = 0, limit: number = 10) {
    try {
      const processInstances = await this.processInstanceRepository.find({
        skip,
        take: limit,
        order: {
          created_at: 'DESC'
        }
      });
      
      return {
        processInstances,
        total: await this.processInstanceRepository.count(),
        skip,
        limit
      };
    } catch (error) {
      console.error("Error getting synced process instances:", error);
      throw error;
    }
  }

  // Method to find process instance by mongoId in SQL database
  async findSyncedProcessInstanceByMongoId(mongoId: string) {
    try {
      return await this.processInstanceRepository.findOne({
        where: { mongoId }
      });
    } catch (error) {
      console.error(`Error finding synced process instance by mongoId ${mongoId}:`, error);
      throw error;
    }
  }

  // Method to find process instances by userId
  async findSyncedProcessInstancesByUserId(userId: string) {
    try {
      return await this.processInstanceRepository.find({
        where: { userId }
      });
    } catch (error) {
      console.error(`Error finding synced process instances by userId ${userId}:`, error);
      throw error;
    }
  }

  // Method to find process instances by processId
  async findSyncedProcessInstancesByProcessId(processId: string) {
    try {
      return await this.processInstanceRepository.find({
        where: { processId }
      });
    } catch (error) {
      console.error(`Error finding synced process instances by processId ${processId}:`, error);
      throw error;
    }
  }

  // Method to find process instances by status
  async findSyncedProcessInstancesByStatus(status: string) {
    try {
      return await this.processInstanceRepository.find({
        where: { status }
      });
    } catch (error) {
      console.error(`Error finding synced process instances by status ${status}:`, error);
      throw error;
    }
  }
}
