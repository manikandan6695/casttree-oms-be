import { Injectable, OnModuleInit } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { taskModel } from "./schema/task.schema";
import { TaskSyncEntity } from "./task-sync.entity";

@Injectable()
export class TaskSyncService implements OnModuleInit {
  constructor(
    @InjectModel("task")
    private readonly taskModel: Model<taskModel>,
    @InjectRepository(TaskSyncEntity)
    private readonly taskRepository: Repository<TaskSyncEntity>
  ) {}

  async onModuleInit() {
    await this.setupChangeStream();
  }

  private async setupChangeStream() {
    const changeStream = this.taskModel.watch([], {
      fullDocument: "updateLookup",
    });

    changeStream.on("change", async (change) => {
      try {
        switch (change.operationType) {
          case "insert":
          case "update":
            await this.handleUpsert(change.fullDocument);
            break;
          case "delete":
            await this.handleDelete(change.documentKey._id);
            break;
        }
      } catch (error) {
        console.error("Error processing task change stream:", error);
      }
    });

    changeStream.on("error", (error) => {
      console.error("Task change stream error:", error);
    });
  }

  private async handleUpsert(task: taskModel) {
    try {
      // Check if task already exists by mongoId
      const existingTask = await this.taskRepository.findOne({
        where: {
          mongoId: task._id.toString()
        }
      });

      if (existingTask) {
        // Update existing task
        const updatedTask = this.mapToTaskEntity(task);
        updatedTask.id = existingTask.id; // Keep the existing UUID
        await this.taskRepository.save(updatedTask);
        console.log(`Updated task ${task._id} in SQL database (title: ${task.title})`);
      } else {
        // Insert new task
        const taskEntity = this.mapToTaskEntity(task);
        await this.taskRepository.save(taskEntity);
        console.log(`Inserted new task ${task._id} to SQL database (title: ${task.title})`);
      }
    } catch (error) {
      console.error(`Error syncing task ${task._id}:`, error);
    }
  }

  private async handleDelete(taskId: string) {
    try {
      // Find and delete by mongoId
      const existingTask = await this.taskRepository.findOne({
        where: {
          mongoId: taskId
        }
      });

      if (existingTask) {
        await this.taskRepository.remove(existingTask);
        console.log(`Deleted task ${taskId} from SQL database`);
      } else {
        console.log(`Task ${taskId} not found in SQL database for deletion`);
      }
    } catch (error) {
      console.error(`Error handling delete for task ${taskId}:`, error);
    }
  }

  private mapToTaskEntity(task: taskModel): TaskSyncEntity {
    const taskEntity = new TaskSyncEntity();
    
    // id will be auto-generated by TypeORM as UUID
    taskEntity.mongoId = task._id.toString();
    taskEntity.title = task.title;
    taskEntity.processId = task.processId?.toString();
    taskEntity.parentProcessId = task.parentProcessId?.toString();
    taskEntity.taskNumber = task.taskNumber;
    taskEntity.type = task.type;
    taskEntity.isLocked = task.isLocked;
    taskEntity.taskMetaData = task.taskMetaData;
    taskEntity.status = task.status;
    
    // Timestamps will be auto-managed by TypeORM
    // created_at and updated_at will be set automatically
    
    return taskEntity;
  }

  // Method to manually trigger sync for existing tasks
  async syncExistingTasks() {
    try {
      console.log("Starting sync of existing tasks...");
      
      const tasks = await this.taskModel.find({}).limit(100); // Limit to avoid memory issues
      
      for (const task of tasks) {
        await this.handleUpsert(task);
      }
      
      console.log(`Successfully synced ${tasks.length} existing tasks`);
    } catch (error) {
      console.error("Error syncing existing tasks:", error);
    }
  }

  // Method to get sync status
  async getSyncStatus() {
    try {
      const totalTasks = await this.taskModel.countDocuments({});
      const syncedTasks = await this.taskRepository.count();
      
      console.log(`Total tasks in MongoDB: ${totalTasks}`);
      console.log(`Total tasks synced to SQL: ${syncedTasks}`);
      
      return {
        totalTasks,
        syncedTasks,
        syncStatus: "active",
        lastSync: new Date()
      };
    } catch (error) {
      console.error("Error getting task sync status:", error);
      throw error;
    }
  }

  // Method to get synced tasks from SQL database
  async getSyncedTasks(skip: number = 0, limit: number = 10) {
    try {
      const tasks = await this.taskRepository.find({
        skip,
        take: limit,
        order: {
          created_at: 'DESC'
        }
      });
      
      return {
        tasks,
        total: await this.taskRepository.count(),
        skip,
        limit
      };
    } catch (error) {
      console.error("Error getting synced tasks:", error);
      throw error;
    }
  }

  // Method to find task by mongoId in SQL database
  async findSyncedTaskByMongoId(mongoId: string) {
    try {
      return await this.taskRepository.findOne({
        where: { mongoId }
      });
    } catch (error) {
      console.error(`Error finding synced task by mongoId ${mongoId}:`, error);
      throw error;
    }
  }

  // Method to find tasks by processId
  async findSyncedTasksByProcessId(processId: string) {
    try {
      return await this.taskRepository.find({
        where: { processId }
      });
    } catch (error) {
      console.error(`Error finding synced tasks by processId ${processId}:`, error);
      throw error;
    }
  }

  // Method to find tasks by parentProcessId
  async findSyncedTasksByParentProcessId(parentProcessId: string) {
    try {
      return await this.taskRepository.find({
        where: { parentProcessId }
      });
    } catch (error) {
      console.error(`Error finding synced tasks by parentProcessId ${parentProcessId}:`, error);
      throw error;
    }
  }

  // Method to find tasks by type
  async findSyncedTasksByType(type: string) {
    try {
      return await this.taskRepository.find({
        where: { type }
      });
    } catch (error) {
      console.error(`Error finding synced tasks by type ${type}:`, error);
      throw error;
    }
  }

  // Method to find tasks by status
  async findSyncedTasksByStatus(status: string) {
    try {
      return await this.taskRepository.find({
        where: { status }
      });
    } catch (error) {
      console.error(`Error finding synced tasks by status ${status}:`, error);
      throw error;
    }
  }

  // Method to find tasks by task number
  async findSyncedTasksByTaskNumber(taskNumber: number) {
    try {
      return await this.taskRepository.find({
        where: { taskNumber }
      });
    } catch (error) {
      console.error(`Error finding synced tasks by task number ${taskNumber}:`, error);
      throw error;
    }
  }

  // Method to get task statistics
  async getTaskStatistics() {
    try {
      const totalTasks = await this.taskRepository.count();
      const activeTasks = await this.taskRepository.count({
        where: { status: "Active" }
      });
      const lockedTasks = await this.taskRepository.count({
        where: { isLocked: true }
      });
      const unlockedTasks = await this.taskRepository.count({
        where: { isLocked: false }
      });

      return {
        totalTasks,
        activeTasks,
        lockedTasks,
        unlockedTasks,
        lastUpdated: new Date()
      };
    } catch (error) {
      console.error("Error getting task statistics:", error);
      throw error;
    }
  }
}
